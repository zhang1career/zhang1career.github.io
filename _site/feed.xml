<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-04-14T15:42:51+08:00</updated><id>/feed.xml</id><title type="html">zhang1career’s Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">设计点赞系统</title><link href="/design/2019/05/05/design-a-like-system.html" rel="alternate" type="text/html" title="设计点赞系统" /><published>2019-05-05T23:50:00+08:00</published><updated>2019-05-05T23:50:00+08:00</updated><id>/design/2019/05/05/design-a-like-system</id><content type="html" xml:base="/design/2019/05/05/design-a-like-system.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;client 假计数，提高用户体验（可选）&lt;/li&gt;
  &lt;li&gt;server 真计数，异步批量计数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;client 拉取目标的点赞信息&lt;/li&gt;
  &lt;li&gt;当用户点击 like/unlike 时，client 向 server 发送请求；同时更新本地的点赞信息（可选）&lt;/li&gt;
  &lt;li&gt;server 把请求放入队列，按照目标分组，异步批量更新的点赞信息&lt;/li&gt;
  &lt;li&gt;client 定期拉取目标的点赞信息，如果计数时间新于本地计数时间，那么就更新本地的点赞信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-名词解释&quot;&gt;A. 名词解释&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;点赞信息：包括 like/unlike 计数、计数时间、此用户对目标的 like/unlike 状态&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="design" /><summary type="html"></summary></entry><entry><title type="html">真·异步读写管道</title><link href="/go/2019/05/03/%E7%9C%9F-%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E7%AE%A1%E9%81%93.html" rel="alternate" type="text/html" title="真·异步读写管道" /><published>2019-05-03T18:00:00+08:00</published><updated>2019-05-03T18:00:00+08:00</updated><id>/go/2019/05/03/%E7%9C%9F%C2%B7%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E7%AE%A1%E9%81%93</id><content type="html" xml:base="/go/2019/05/03/%E7%9C%9F-%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E7%AE%A1%E9%81%93.html">&lt;blockquote&gt;
  &lt;p&gt;无缓存管道要求写入和读取的同步配合；缓存管道受到缓存深度影响，依然可能造成管道阻塞。本文提出一种无阻塞读写的管道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;真异步读写管道&quot;&gt;真·异步读写管道&lt;/h1&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;由程序逻辑实现在两个管道。一个只写，一个只读；二者异步操作[1]&lt;/li&gt;
  &lt;li&gt;提供 fire-and-forget 特性。降低应用开发难度；受到缓存深度影响，写入数据可能丢失&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;创建两个管道。一个只写（in 管道），一个只读（out 管道）&lt;/li&gt;
  &lt;li&gt;监听 in 管道。把数据放入缓存；如果缓存满了就删除最老的数据，写入最新的数据&lt;/li&gt;
  &lt;li&gt;监听 out 管道。输出缓存数据；如果缓存空了就不操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-实现&quot;&gt;3. 实现&lt;/h2&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type infinite struct {
    in          chan interface{}
    out         chan interface{}
    buffer      []interface{}
    bufLength   int
}
 
func NewInfinite(length int) (chan&amp;lt;- interface{}, &amp;lt;-chan interface{}, error) {
    if length &amp;lt;= 0 {
        return nil, nil, fmt.Errorf(&quot;length should be natural number&quot;)
    }
    
    item := &amp;amp;infinite{
        in     : make(chan interface{}),
        out    : make(chan interface{}),
        buffer : make([]interface{}, 0),
        bufLength : length,
    }
    
    go func() {
        defer close(item.out)
        item.transceive()
    }()
    
   return item.in, item.out, nil
}
 
func (this *infinite) outChannel() chan interface{} {
    if len(this.buffer) == 0 {
        return nil
    }
    return this.out
}
 
func (this *infinite) outValue() interface{} {
    if len(this.buffer) == 0 {
        return nil
    }
    return this.buffer[0]
}
 
func (this *infinite) popValue() {
    if len(this.buffer) == 0 {
        return
    }
    this.buffer = this.buffer[1:]
}
 
func (this *infinite) pushValue(value interface{}) {
    // replace oldest value by newest value
    if len(this.buffer) &amp;gt;= this.bufLength {
        this.popValue()
    }
    this.buffer = append(this.buffer, value)
}
 
func (this *infinite) transceive() {
    for {
        select {
        case v, ok := &amp;lt;- this.in:
            if !ok {
                this.in = nil
                return
            }
            this.pushValue(v)
        case this.outChannel() &amp;lt;- this.outValue():
            this.popValue()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func TestNewInfinite(t *testing.T) {
    // enviroment data
    bufferSize := 0
    in, out, err := NewInfinite(bufferSize)
    if err != nil {
        t.Error(err)
        return
    }
    // reading
    go func() {
        for {
            select {
            case v, ok := &amp;lt;- out:
                if !ok {
                    fmt.Println(&quot;in has been closed&quot;)
                    return
                }
                vi := v.(int)
                fmt.Println(vi)
            }
        }
        fmt.Println(&quot;finished redading&quot;)
    }()
    // writing
    for i := 0; i &amp;lt; 100; i++ {
        fmt.Println(&quot;writing&quot;, i)
        in &amp;lt;- i
    }
    // closing
    close(in)
    fmt.Println(&quot;finished writing&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a-参考&quot;&gt;A. 参考&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/capital-one-tech/building-an-unbounded-channel-in-go-789e175cd2cd&quot;&gt;Building an Unbounded Channel in Go&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="go" /><summary type="html">无缓存管道要求写入和读取的同步配合；缓存管道受到缓存深度影响，依然可能造成管道阻塞。本文提出一种无阻塞读写的管道。</summary></entry><entry><title type="html">协程的可观测性——协程如何传出运行信息</title><link href="/go/2019/05/03/how-to-observe-a-goroutine.html" rel="alternate" type="text/html" title="协程的可观测性——协程如何传出运行信息" /><published>2019-05-03T17:20:00+08:00</published><updated>2019-05-03T17:20:00+08:00</updated><id>/go/2019/05/03/how-to-observe-a-goroutine</id><content type="html" xml:base="/go/2019/05/03/how-to-observe-a-goroutine.html">&lt;blockquote&gt;
  &lt;p&gt;协程可以由管道从外部进行控制，控制的依据一般是协程运行信息。本文提出一种协程传出运行信息的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;协程的可观测性协程如何传出运行信息&quot;&gt;协程的可观测性——协程如何传出运行信息&lt;/h1&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;基于 context.Context 的 key-value，实现协程传出运行信息的功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;父协程创建 channel 并放入 context.Context.WithValue，将 context 传递给子协程&lt;/li&gt;
  &lt;li&gt;子协程向 channel 写入运行信息&lt;/li&gt;
  &lt;li&gt;父协程从 channel 读取运行信息，实现监控&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const key = &quot;info&quot;

func parent() {
    // 创建 channel
    listener := make(chan interface{})
    ctx := context.WithValue(context.Background(), key, listener)
    defer ctx.Done()
    // 启动子协程
    go children(ctx)
    // 监控运行信息
    for {
        select {
        case o := &amp;lt;- listener:
            fmt.Println(&quot;children running&quot;, o)
        }
        default:
            time.Sleep(100 * time.Millisecond)
    }    
}
 
func children(ctx context.Context) {
    v := ctx.Value(key).(chan&amp;lt;- interface{})
    if v == nil {
        fmt.Println(&quot;context key not found:&quot;, key)
        return
    }
    defer close(v)
    // 子协程定期向 channel 中写入运行信息
    tick := time.Tick(time.Second)
    for {
        select {
        case t := &amp;lt;- tick:
            v &amp;lt;- t
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-实现&quot;&gt;3. 实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;子协程定期向 channel 写入心跳信号&lt;/li&gt;
  &lt;li&gt;父协程监控心跳信号，如果一段时间内没有收到心跳信号，那么认为子协程发生运行故障&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const key = &quot;heartbeat&quot;
 
func main() {
    // 父协程创建 channel
    listener := make(chan interface{})
    ctx := context.WithValue(context.Background(), key, listener)
    defer ctx.Done()
    // 启动子协程
    go children(ctx)
    // 父协程监控心跳信号
    for o := range listener {
        fmt.Println(o)
    }
    fmt.Println(&quot;no heartbeat!!!&quot;)
}
 
func children(ctx context.Context) {
    v := ctx.Value(key).(chan&amp;lt;- interface{})
    if v == nil {
        fmt.Println(&quot;context key not found:&quot;, key)
        return
    }
    defer close(v)
    // 子协程定期向 channel 中写入心跳信号
    tick := time.Tick(time.Second)
    for {
        select {
        case t := &amp;lt;- tick:
            v &amp;lt;- t
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a-名词解释&quot;&gt;A. 名词解释&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;运行故障：协程在运行期间的不可预期状态，包含阻塞、死循环等。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="go" /><summary type="html">协程可以由管道从外部进行控制，控制的依据一般是协程运行信息。本文提出一种协程传出运行信息的方法。</summary></entry><entry><title type="html">如何比较 go 的结构体</title><link href="/go/2019/04/30/how-to-compare-go-structs.html" rel="alternate" type="text/html" title="如何比较 go 的结构体" /><published>2019-04-30T21:35:00+08:00</published><updated>2019-04-30T21:35:00+08:00</updated><id>/go/2019/04/30/how-to-compare-go-structs</id><content type="html" xml:base="/go/2019/04/30/how-to-compare-go-structs.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;如果元素类型不同、顺序不同，那么结构体不可比较&lt;/li&gt;
  &lt;li&gt;如果元素包含不可比较类型（map, slice），那么结构体不可比较&lt;/li&gt;
  &lt;li&gt;对于不可比较的结构体，使用 == 会报错，而应该使用 reflect.DeepEqual&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-实现&quot;&gt;2. 实现&lt;/h2&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sn1 := struct {
    age  int
    name string
}{age: 11, name: &quot;qq&quot;}
 
 
sn2 := struct {
    age  int
    name string
}{age: 11, name: &quot;qq&quot;}
 
if reflect.DeepEqual(sn1, sn2) {
    fmt.Println(&quot;sn1 == sn2&quot;)
} else {
    fmt.Println(&quot;sn1 != sn2&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="go" /><summary type="html"></summary></entry><entry><title type="html">如何选择可变管道</title><link href="/go/2019/04/30/how-to-select-variadic-channel.html" rel="alternate" type="text/html" title="如何选择可变管道" /><published>2019-04-30T20:30:00+08:00</published><updated>2019-04-30T20:30:00+08:00</updated><id>/go/2019/04/30/how-to-select-variadic-channel</id><content type="html" xml:base="/go/2019/04/30/how-to-select-variadic-channel.html">&lt;h1 id=&quot;如何选择可变管道&quot;&gt;如何选择可变管道&lt;/h1&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可变参数的接收[1]&lt;/li&gt;
  &lt;li&gt;递归 select&lt;/li&gt;
  &lt;li&gt;reflect.Select[2]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h2&gt;

&lt;h3 id=&quot;21递归-select&quot;&gt;2.1.递归 select&lt;/h3&gt;
&lt;p&gt;递归 select 属于运行时多态，可变管道是编译时多态。使用前者对后者予以降维打击&lt;/p&gt;

&lt;h3 id=&quot;22-reflectselect3&quot;&gt;2.2. reflect.Select[3]&lt;/h3&gt;

&lt;p&gt;使用到如下字段：
Field  | Value | Meaning
—— | —– | ——
chosen |       | 通道序号
recv   |       | 接收内容
recvOK | true  | 通道正常工作
       | false | 通道已经关闭&lt;/p&gt;

&lt;h2 id=&quot;3-示例&quot;&gt;3. 示例&lt;/h2&gt;

&lt;h3 id=&quot;32-reflectselect&quot;&gt;3.2. reflect.Select&lt;/h3&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)
 
func Mux(out chan&amp;lt;- interface{}, varIns ...&amp;lt;-chan interface{}) {
    ins := make([]&amp;lt;-chan interface{}, 0)
    if len(varIns) &amp;gt; 0 {
       for _, in := range varIns {
          ins = append(ins, in)
       }
    }
    
    cases := make([]reflect.SelectCase, len(ins))
    for i, in := range ins {
        cases[i] = reflect.SelectCase{Dir: reflect.SelectRecv, Chan: reflect.ValueOf(in)}
    }
    
    remaining := len(cases)
    for remaining &amp;gt; 0 {
        chosen, value, ok := reflect.Select(cases)
        // The chosen channel has been closed, so zero out the channel to disable the case
        if !ok {
            cases[chosen].Chan = reflect.ValueOf(nil)
            remaining -= 1
            continue
        }
        fmt.Printf(&quot;Channel%#v: %s\n&quot;, ins[chosen], value.String())
        out &amp;lt;- value
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a-参考&quot;&gt;A. 参考&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhagn1career.github.io/go/2019/02/14/how-to-handle-variadic-function.html&quot;&gt;如何实现变参函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/19992334/how-to-listen-to-n-channels-dynamic-select-statement&quot;&gt;You Should use reflect.Select&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://golang.org/pkg/reflect/#Select&quot;&gt;reflect.Select&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tevic.github.io/2016/05/10/select-case/&quot;&gt;使用SelectCase来做不定数量的channel选择&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="go" /><summary type="html">如何选择可变管道</summary></entry><entry><title type="html">如何实现 map 排序</title><link href="/go/2019/04/30/how-to-sort-a-go-map.html" rel="alternate" type="text/html" title="如何实现 map 排序" /><published>2019-04-30T20:10:00+08:00</published><updated>2019-04-30T20:10:00+08:00</updated><id>/go/2019/04/30/how-to-sort-a-go-map</id><content type="html" xml:base="/go/2019/04/30/how-to-sort-a-go-map.html">&lt;h1 id=&quot;如何实现-map-排序&quot;&gt;如何实现 map 排序&lt;/h1&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;map 是无序的&lt;/li&gt;
  &lt;li&gt;先把 map 转换成 array，再对 array 排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-实现&quot;&gt;2. 实现&lt;/h2&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type KV struct {
    Key: int
    Value: interface{}
}

func SortMap(m map[int]interface{}) []KV {
    var keys []int
    
    for k := range m {
        keys = append(keys, k)
    }
    sort.Ints(keys)
    
    ret := make([]KV, len(m))
    for i, k := range keys {
        ret[i] = KV{Key: k, Value: m[k]}
    }
    
    return ret
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="go" /><summary type="html">如何实现 map 排序</summary></entry><entry><title type="html">如何 prepend 切片</title><link href="/go/2019/02/15/how-to-prepend-a-go-slice.html" rel="alternate" type="text/html" title="如何 prepend 切片" /><published>2019-02-15T22:30:00+08:00</published><updated>2019-02-15T22:30:00+08:00</updated><id>/go/2019/02/15/how-to-prepend-a-go-slice</id><content type="html" xml:base="/go/2019/02/15/how-to-prepend-a-go-slice.html">&lt;h1 id=&quot;如何-prepend-切片&quot;&gt;如何 prepend 切片&lt;/h1&gt;

&lt;h2 id=&quot;1-示例&quot;&gt;1. 示例&lt;/h2&gt;

&lt;p&gt;直接上码：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func Prepend(slice []interface{}, elems ...interface{}) []interface{} {
   if len(elems) &amp;lt;= 0 {
      return slice
   }
    
   ret := slice
   for i := len(elems)-1; i &amp;gt;= 0; i-- {
      ret = append([]interface{}{elems[i]}, ret...)
   }
   return ret
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="go" /><summary type="html">如何 prepend 切片</summary></entry><entry><title type="html">如何实现管道的多路选择</title><link href="/go/2019/02/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AE%A1%E9%81%93%E7%9A%84%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9.html" rel="alternate" type="text/html" title="如何实现管道的多路选择" /><published>2019-02-14T22:50:00+08:00</published><updated>2019-02-14T22:50:00+08:00</updated><id>/go/2019/02/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AE%A1%E9%81%93%E7%9A%84%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9</id><content type="html" xml:base="/go/2019/02/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AE%A1%E9%81%93%E7%9A%84%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9.html">&lt;h1 id=&quot;如何实现管道的多路选择&quot;&gt;如何实现管道的多路选择&lt;/h1&gt;

&lt;h2 id=&quot;1-实现&quot;&gt;1. 实现&lt;/h2&gt;

&lt;p&gt;直接上码：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func mux(out chan&amp;lt;- interface{}, in1, in2 &amp;lt;-chan interface{}) {
	var inBuffer []interface{}
	var value interface{}
	
	for {
		var outBuffer chan&amp;lt;- interface{}
		
		if len(inBuffer) &amp;gt; 0 {
			outBuffer = out
			value = inBuffer[0]
		}
		
		select {
		// inputs
		case in, ok := &amp;lt;-in1:
			if ok {
				inBuffer = append(inBuffer, in)
			}
		case in, ok := &amp;lt;-in2:
			if ok {
				inBuffer = append(inBuffer, in)
			}
		// output
		case outBuffer &amp;lt;- value:
			inBuffer = inBuffer[1:]
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a-参考&quot;&gt;A. 参考&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://coding.imooc.com/class/chapter/180.html#Anchor&quot;&gt;深度讲解Go语言&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="go" /><summary type="html">如何实现管道的多路选择</summary></entry><entry><title type="html">如何实现 go 变参函数</title><link href="/go/2019/02/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-go-%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0.html" rel="alternate" type="text/html" title="如何实现 go 变参函数" /><published>2019-02-14T20:30:00+08:00</published><updated>2019-02-14T20:30:00+08:00</updated><id>/go/2019/02/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20go%20%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0</id><content type="html" xml:base="/go/2019/02/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-go-%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0.html">&lt;h1 id=&quot;如何实现-go-变参函数&quot;&gt;如何实现 go 变参函数&lt;/h1&gt;

&lt;h2 id=&quot;1-实现&quot;&gt;1. 实现&lt;/h2&gt;

&lt;p&gt;直接上码：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func demo(params ...interface{}) {
    s := make([]interface{}, 0)
    if len(args) &amp;gt; 0 {
        for _, p := range params {
            s = append(s, p)
        }
    }
    fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="go" /><summary type="html">如何实现 go 变参函数</summary></entry></feed>