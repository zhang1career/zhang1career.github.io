<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-05-04T23:21:32+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">zhang1career’s Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">如何实现真正异步读写的管道</title><link href="http://localhost:4000/go/2019/05/03/how-to-fire-and-forget-a-channel.html" rel="alternate" type="text/html" title="如何实现真正异步读写的管道" /><published>2019-05-03T18:00:00+08:00</published><updated>2019-05-03T18:00:00+08:00</updated><id>http://localhost:4000/go/2019/05/03/how-to-fire-and-forget-a-channel</id><content type="html" xml:base="http://localhost:4000/go/2019/05/03/how-to-fire-and-forget-a-channel.html">&lt;blockquote&gt;
  &lt;p&gt;使用管道并不轻松。无缓存管道要求写入和读取的同步配合；缓存管道受到缓存深度影响，依然可能造成管道阻塞。
本文提出一种无阻塞读写的管道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;由程序逻辑实现在二个管道。一个只写，一个只读；二者异步操作[1]&lt;/li&gt;
  &lt;li&gt;提供 fire-and-forget 特性。降低应用开发难度；受到缓存深度影响，写入数据可能丢失&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;创建二个管道。一个只写（in 管道），一个只读（out 管道）&lt;/li&gt;
  &lt;li&gt;监听 in 管道。把数据放入缓存；如果缓存满了就删除最老的数据，写入最新的数据&lt;/li&gt;
  &lt;li&gt;监听 out 管道。输出缓存数据；如果缓存空了就不操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-实现&quot;&gt;3. 实现&lt;/h2&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type infinite struct {
    in          chan interface{}
    out         chan interface{}
    buffer      []interface{}
    bufLength   int
}
 
func NewInfinite(length int) (chan&amp;lt;- interface{}, &amp;lt;-chan interface{}, error) {
    if length &amp;lt;= 0 {
        return nil, nil, fmt.Errorf(&quot;length should be natural number&quot;)
    }
    
    item := &amp;amp;infinite{
        in     : make(chan interface{}),
        out    : make(chan interface{}),
        buffer : make([]interface{}, 0),
        bufLength : length,
    }
    
    go func() {
        defer close(item.out)
        item.transceive()
    }()
    
   return item.in, item.out, nil
}
 
func (this *infinite) outChannel() chan interface{} {
    if len(this.buffer) == 0 {
        return nil
    }
    return this.out
}
 
func (this *infinite) outValue() interface{} {
    if len(this.buffer) == 0 {
        return nil
    }
    return this.buffer[0]
}
 
func (this *infinite) popValue() {
    if len(this.buffer) == 0 {
        return
    }
    this.buffer = this.buffer[1:]
}
 
func (this *infinite) pushValue(value interface{}) {
    // replace oldest value by newest value
    if len(this.buffer) &amp;gt;= this.bufLength {
        this.popValue()
    }
    this.buffer = append(this.buffer, value)
}
 
func (this *infinite) transceive() {
    for {
        select {
        case v, ok := &amp;lt;- this.in:
            if !ok {
                this.in = nil
                return
            }
            this.pushValue(v)
        case this.outChannel() &amp;lt;- this.outValue():
            this.popValue()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func TestNewInfinite(t *testing.T) {
    // enviroment data
    bufferSize := 0
    in, out, err := NewInfinite(bufferSize)
    if err != nil {
        t.Error(err)
        return
    }
    // reading
    go func() {
        for {
            select {
            case v, ok := &amp;lt;- out:
                if !ok {
                    fmt.Println(&quot;in has been closed&quot;)
                    return
                }
                vi := v.(int)
                fmt.Println(vi)
            }
        }
        fmt.Println(&quot;finished redading&quot;)
    }()
    // writing
    for i := 0; i &amp;lt; 100; i++ {
        fmt.Println(&quot;writing&quot;, i)
        in &amp;lt;- i
    }
    // closing
    close(in)
    fmt.Println(&quot;finished writing&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a-参考&quot;&gt;A. 参考&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/capital-one-tech/building-an-unbounded-channel-in-go-789e175cd2cd&quot;&gt;Building an Unbounded Channel in Go&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">使用管道并不轻松。无缓存管道要求写入和读取的同步配合；缓存管道受到缓存深度影响，依然可能造成管道阻塞。 本文提出一种无阻塞读写的管道。</summary></entry><entry><title type="html">协程的可观测性——协程如何传出运行信息</title><link href="http://localhost:4000/go/2019/05/03/how-to-observe-a-goroutine.html" rel="alternate" type="text/html" title="协程的可观测性——协程如何传出运行信息" /><published>2019-05-03T17:20:00+08:00</published><updated>2019-05-03T17:20:00+08:00</updated><id>http://localhost:4000/go/2019/05/03/how-to-observe-a-goroutine</id><content type="html" xml:base="http://localhost:4000/go/2019/05/03/how-to-observe-a-goroutine.html">&lt;blockquote&gt;
  &lt;p&gt;协程可以由管道从外部进行控制，控制的依据一般是协程运行信息。但是协程外部如何获得协程运行信息，目前鲜有资讯提及。本文提出一种协程传出运行信息的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基于 context.Context 的 key-value，实现协程传出运行信息的功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;父协程创建 channel 并放入 context.Context.WithValue，将 context 传递给子协程&lt;/li&gt;
  &lt;li&gt;子协程向 channel 写入运行信息&lt;/li&gt;
  &lt;li&gt;父协程从 channel 读取运行信息，实现监控&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const key = &quot;info&quot;

func parent() {
    // 创建 channel
    listener := make(chan interface{})
    ctx := context.WithValue(context.Background(), key, listener)
    defer ctx.Done()
    // 启动子协程
    go children(ctx)
    // 监控运行信息
    for {
        select {
        case o := &amp;lt;- listener:
            fmt.Println(&quot;children running&quot;, o)
        }
        default:
            time.Sleep(100 * time.Millisecond)
    }    
}
 
func children(ctx context.Context) {
    v := ctx.Value(key).(chan&amp;lt;- interface{})
    if v == nil {
        fmt.Println(&quot;context key not found:&quot;, key)
        return
    }
    defer close(v)
    // 子协程定期向 channel 中写入运行信息
    tick := time.Tick(time.Second)
    for {
        select {
        case t := &amp;lt;- tick:
            v &amp;lt;- t
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-实现&quot;&gt;3. 实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;子协程定期向 channel 写入心跳信号&lt;/li&gt;
  &lt;li&gt;父协程监控心跳信号，如果一段时间内没有收到心跳信号，那么认为子协程发生运行故障&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const key = &quot;heartbeat&quot;
 
func main() {
    // 父协程创建 channel
    listener := make(chan interface{})
    ctx := context.WithValue(context.Background(), key, listener)
    defer ctx.Done()
    // 启动子协程
    go children(ctx)
    // 父协程监控心跳信号
    for o := range listener {
        fmt.Println(o)
    }
    fmt.Println(&quot;no heartbeat!!!&quot;)
}
 
func children(ctx context.Context) {
    v := ctx.Value(key).(chan&amp;lt;- interface{})
    if v == nil {
        fmt.Println(&quot;context key not found:&quot;, key)
        return
    }
    defer close(v)
    // 子协程定期向 channel 中写入心跳信号
    tick := time.Tick(time.Second)
    for {
        select {
        case t := &amp;lt;- tick:
            v &amp;lt;- t
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a-名词解释&quot;&gt;A. 名词解释&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;运行故障：协程在运行期间的不可预期状态，包含阻塞、死循环等。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">协程可以由管道从外部进行控制，控制的依据一般是协程运行信息。但是协程外部如何获得协程运行信息，目前鲜有资讯提及。本文提出一种协程传出运行信息的方法。</summary></entry><entry><title type="html">如何实现 go 的时效控制</title><link href="http://localhost:4000/go/2019/04/30/how-to-timing-in-go.html" rel="alternate" type="text/html" title="如何实现 go 的时效控制" /><published>2019-04-30T22:35:00+08:00</published><updated>2019-04-30T22:35:00+08:00</updated><id>http://localhost:4000/go/2019/04/30/how-to-timing-in-go</id><content type="html" xml:base="http://localhost:4000/go/2019/04/30/how-to-timing-in-go.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-实现&quot;&gt;1. 实现&lt;/h2&gt;

&lt;p&gt;直接上码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func timing(out chan&amp;lt;- interface{}, in1, in2 &amp;lt;-chan interface{}) {
    heartbeat := time.Tick(time.Second)
	lifetime := time.After(10 * time.Second)
	for {
		select {
		// heartbeat
		case &amp;lt;-heartbeat:
			fmt.Println(&quot;queue len =&quot;, len(inBuffer))
		// lifetime
		case &amp;lt;-lifetime:
			fmt.Println(&quot;bye&quot;)
			return
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Go 闭包何时计算</title><link href="http://localhost:4000/go/2019/04/30/when-does-a-go-closure-calc.html" rel="alternate" type="text/html" title="Go 闭包何时计算" /><published>2019-04-30T22:35:00+08:00</published><updated>2019-04-30T22:35:00+08:00</updated><id>http://localhost:4000/go/2019/04/30/when-does-a-go-closure-calc</id><content type="html" xml:base="http://localhost:4000/go/2019/04/30/when-does-a-go-closure-calc.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-实现&quot;&gt;1. 实现&lt;/h2&gt;

&lt;p&gt;直接上码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func calcLate() []func()  {
    var funs []func()
    for i:=0; i&amp;lt;2; i++  {
        funs = append(funs, func() {
            println(&amp;amp;i, i)
        })
    }
    return funs
}
 
func calcNow() []func()  {
    var funs []func()
    for i:=0; i&amp;lt;2; i++  {
        x := i
        funs = append(funs, func() {
            println(&amp;amp;x, x)
        })
    }
    return funs
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;funsLate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calcLate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;funsLate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;funsNow&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calcLate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;funsNow&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">如何比较 go 的结构体</title><link href="http://localhost:4000/go/2019/04/30/how-to-compare-go-structs.html" rel="alternate" type="text/html" title="如何比较 go 的结构体" /><published>2019-04-30T21:35:00+08:00</published><updated>2019-04-30T21:35:00+08:00</updated><id>http://localhost:4000/go/2019/04/30/how-to-compare-go-structs</id><content type="html" xml:base="http://localhost:4000/go/2019/04/30/how-to-compare-go-structs.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;如果元素类型不同、顺序不同，那么结构体不可比较&lt;/li&gt;
  &lt;li&gt;如果元素包含不可比较类型（map, slice），那么结构体不可比较&lt;/li&gt;
  &lt;li&gt;对于不可比较的结构体，使用 == 会报错，而应该使用 reflect.DeepEqual&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-实现&quot;&gt;2. 实现&lt;/h2&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sn1 := struct {
    age  int
    name string
}{age: 11, name: &quot;qq&quot;}
 
 
sn2 := struct {
    age  int
    name string
}{age: 11, name: &quot;qq&quot;}
 
if reflect.DeepEqual(sn1, sn2) {
    fmt.Println(&quot;sn1 == sn2&quot;)
} else {
    fmt.Println(&quot;sn1 != sn2&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">如何选择可变管道</title><link href="http://localhost:4000/go/2019/04/30/how-to-select-variadic-channel.html" rel="alternate" type="text/html" title="如何选择可变管道" /><published>2019-04-30T20:30:00+08:00</published><updated>2019-04-30T20:30:00+08:00</updated><id>http://localhost:4000/go/2019/04/30/how-to-select-variadic-channel</id><content type="html" xml:base="http://localhost:4000/go/2019/04/30/how-to-select-variadic-channel.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;可变参数的接收[1]&lt;/li&gt;
  &lt;li&gt;递归 select&lt;/li&gt;
  &lt;li&gt;reflect.Select[2]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h2&gt;

&lt;h3 id=&quot;21递归-select&quot;&gt;2.1.递归 select&lt;/h3&gt;
&lt;p&gt;递归 select 属于运行时多态，可变管道是编译时多态。使用前者对后者予以降维打击&lt;/p&gt;

&lt;h3 id=&quot;22-reflectselect3&quot;&gt;2.2. reflect.Select[3]&lt;/h3&gt;

&lt;p&gt;使用到如下字段：
Field  | Value | Meaning
—— | —– | ——
chosen |       | 通道序号
recv   |       | 接收内容
recvOK | true  | 通道正常工作
       | false | 通道已经关闭&lt;/p&gt;

&lt;h2 id=&quot;3-示例&quot;&gt;3. 示例&lt;/h2&gt;

&lt;h3 id=&quot;32-reflectselect&quot;&gt;3.2. reflect.Select&lt;/h3&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)
 
func Mux(out chan&amp;lt;- interface{}, varIns ...&amp;lt;-chan interface{}) {
    ins := make([]&amp;lt;-chan interface{}, 0)
    if len(varIns) &amp;gt; 0 {
       for _, in := range varIns {
          ins = append(ins, in)
       }
    }
    
    cases := make([]reflect.SelectCase, len(ins))
    for i, in := range ins {
        cases[i] = reflect.SelectCase{Dir: reflect.SelectRecv, Chan: reflect.ValueOf(in)}
    }
    
    remaining := len(cases)
    for remaining &amp;gt; 0 {
        chosen, value, ok := reflect.Select(cases)
        // The chosen channel has been closed, so zero out the channel to disable the case
        if !ok {
            cases[chosen].Chan = reflect.ValueOf(nil)
            remaining -= 1
            continue
        }
        fmt.Printf(&quot;Channel%#v: %s\n&quot;, ins[chosen], value.String())
        out &amp;lt;- value
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a-参考&quot;&gt;A. 参考&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhagn1career.github.io/go/2019/02/14/how-to-handle-variadic-function.html&quot;&gt;如何实现变参函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/19992334/how-to-listen-to-n-channels-dynamic-select-statement&quot;&gt;You Should use reflect.Select&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://golang.org/pkg/reflect/#Select&quot;&gt;reflect.Select&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tevic.github.io/2016/05/10/select-case/&quot;&gt;使用SelectCase来做不定数量的channel选择&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">如何实现 map 排序</title><link href="http://localhost:4000/go/2019/04/30/how-to-sort-a-go-map.html" rel="alternate" type="text/html" title="如何实现 map 排序" /><published>2019-04-30T20:10:00+08:00</published><updated>2019-04-30T20:10:00+08:00</updated><id>http://localhost:4000/go/2019/04/30/how-to-sort-a-go-map</id><content type="html" xml:base="http://localhost:4000/go/2019/04/30/how-to-sort-a-go-map.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;map 是无序的&lt;/li&gt;
  &lt;li&gt;先把 map 转换成 array，再对 array 排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-实现&quot;&gt;2. 实现&lt;/h2&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type KV struct {
    Key: int
    Value: interface{}
}

func SortMap(m map[int]interface{}) []KV {
    var keys []int
    
    for k := range m {
        keys = append(keys, k)
    }
    sort.Ints(keys)
    
    ret := make([]KV, len(m))
    for i, k := range keys {
        ret[i] = KV{Key: k, Value: m[k]}
    }
    
    return ret
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Troubleshooting for Http</title><link href="http://localhost:4000/troubleshooting/2019/04/22/troubleshooting-for-http.html" rel="alternate" type="text/html" title="Troubleshooting for Http" /><published>2019-04-22T23:16:00+08:00</published><updated>2019-04-22T23:16:00+08:00</updated><id>http://localhost:4000/troubleshooting/2019/04/22/troubleshooting-for-http</id><content type="html" xml:base="http://localhost:4000/troubleshooting/2019/04/22/troubleshooting-for-http.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-status-code1&quot;&gt;1. Status Code[1]&lt;/h2&gt;

&lt;h3 id=&quot;302-found&quot;&gt;302 Found&lt;/h3&gt;
&lt;p&gt;A common way of performing URL redirection.&lt;/p&gt;

&lt;h3 id=&quot;400-bad-request&quot;&gt;400 Bad Request&lt;/h3&gt;
&lt;p&gt;Cause&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the HTTP request that was sent to the server has invalid syntax.&lt;/li&gt;
  &lt;li&gt;the user’s cookie that is associated with the site is corrupt.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Checkage&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;clearing the browser’s cache and cookies could solve this issue&lt;/li&gt;
  &lt;li&gt;malformed request due to a faulty browser&lt;/li&gt;
  &lt;li&gt;malformed request due to human error when manually forming HTTP requests (e.g. using curl incorrectly)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;401--unauthorized-error&quot;&gt;401  Unauthorized Error&lt;/h3&gt;
&lt;p&gt;Client-side checkage&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;check if inputting an incorrect URL&lt;/li&gt;
  &lt;li&gt;clear cookies to update auth info&lt;/li&gt;
  &lt;li&gt;clear cache to refresh webpage&lt;/li&gt;
  &lt;li&gt;logout and login&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Server-side checkage&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;confirm the WWW-Authenticate Header&lt;/li&gt;
  &lt;li&gt;check Web Server Configuration&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;403-forbidden&quot;&gt;403 Forbidden&lt;/h3&gt;
&lt;p&gt;Cause&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the server understood the request, but will not fulfill it due to client related issues.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;404-not-found&quot;&gt;404 Not Found&lt;/h3&gt;
&lt;p&gt;Checkage&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;nginx try_files settings&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;451-unavailable-for-legal-reasons&quot;&gt;451 Unavailable For Legal Reasons&lt;/h3&gt;
&lt;p&gt;Cause&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the webpage censored by a government&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;500-internal-server-error&quot;&gt;500 Internal Server Error&lt;/h3&gt;
&lt;p&gt;Checkage&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;programing&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;502-bad-gateway&quot;&gt;502 Bad Gateway&lt;/h3&gt;
&lt;p&gt;Cause&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the server is a gateway or proxy server, and it is not receiving a valid response from the backend servers that should actually fulfill the request.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If the server in question is a reverse proxy server, such as a load balancer, here are a few checkage&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the backend servers (where the HTTP requests are being forwarded to) are healthy&lt;/li&gt;
  &lt;li&gt;the reverse proxy is configured properly, with the proper backends specified&lt;/li&gt;
  &lt;li&gt;the network connection between the backend servers and reverse proxy server is healthy. If the servers can communicate on other ports, make sure that the firewall is allowing the traffic between them&lt;/li&gt;
  &lt;li&gt;if your web application is configured to listen on a socket, ensure that the socket exists in the correct location and that it has the proper permissions&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;503-service-unavailable&quot;&gt;503 Service Unavailable&lt;/h3&gt;
&lt;p&gt;The server is not ready to handle the request.&lt;/p&gt;

&lt;p&gt;Cause&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a server being down for maintenance or being overloaded&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Caution
Caching-related headers that are sent along with this response should be taken care of, as a 503 status is often a temporary condition and responses shouldn’t usually be cached.&lt;/p&gt;

&lt;h3 id=&quot;504-gateway-timeout&quot;&gt;504 Gateway Timeout&lt;/h3&gt;
&lt;p&gt;A different computer that doesn’t control but relies on, isn’t communicating with quickly enough.&lt;/p&gt;

&lt;h2 id=&quot;a-reference&quot;&gt;A. Reference&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-troubleshoot-common-http-error-codes&quot;&gt;How To Troubleshoot Common HTTP Error Codes&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">如何从 go 的应用代码抽象出通用代码</title><link href="http://localhost:4000/go/2019/02/17/how-to-abstract-code.html" rel="alternate" type="text/html" title="如何从 go 的应用代码抽象出通用代码" /><published>2019-02-17T21:40:00+08:00</published><updated>2019-02-17T21:40:00+08:00</updated><id>http://localhost:4000/go/2019/02/17/how-to-abstract-code</id><content type="html" xml:base="http://localhost:4000/go/2019/02/17/how-to-abstract-code.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-要点&quot;&gt;1. 要点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;可以使用回调函数&lt;/li&gt;
  &lt;li&gt;可以使用回调接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h2&gt;

&lt;h3 id=&quot;21回调函数&quot;&gt;2.1.回调函数&lt;/h3&gt;
&lt;p&gt;通用代码保留在通用函数中；把应用代码写入回调函数中；把回调函数作为参数传给通用函数，供其调用。&lt;/p&gt;

&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这是代码抽象的基本方式&lt;/li&gt;
  &lt;li&gt;编译时多态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不是运行时多态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-回调接口&quot;&gt;2.2. 回调接口&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;通用代码定义实例接口，应用代码实现这个接口&lt;/li&gt;
  &lt;li&gt;动态代理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;运行时多态&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-示例&quot;&gt;3. 示例&lt;/h2&gt;

&lt;h3 id=&quot;31-通用代码&quot;&gt;3.1. 通用代码&lt;/h3&gt;

&lt;p&gt;定义 Work 接口，执行 Work 接口定义的 Do()：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Work interface {
    Do() interface{}
}

type worker struct {
    id      int
    Work
}

func createWorker(id int, work Work) *worker {
    return &amp;amp;worker{id: id, Work: work}
}
 
func (this *worker) run() {
    go func() {
        // 执行 Work 接口定义的 Do()
    }()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接收应用代码创建的实例，执行相应的 Do()&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (this *Parser) AddWorker(num int, out chan int, callback chan Work) {
    for i := 0; i &amp;lt; num; i++ {
        out &amp;lt;- i
        work := &amp;lt;- callback
        worker := createWorker(i, work)
        worker.run()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-应用代码&quot;&gt;3.2. 应用代码&lt;/h3&gt;

&lt;p&gt;实现 Work 接口：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (this *snowflake) Do() interface{} {
   return fmt.SPrintf(&quot;worker%d doing&quot;, this.id)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建实例，以 Work 接口返回给通用代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func CreateSnowFlow(machineIds chan int) chan Work {
   output := make(chan Work)
   go func() {
      defer close(output)
      for {
         select {
         case id := &amp;lt;-machineIds:
            output &amp;lt;- createSnowFlake(id)
         }
      }
   }()
   return output
}

type snowflake struct {
   id int
}

func createSnowFlake(id int) *snowflake {
   return &amp;amp;snowflake{id: id}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-测试代码&quot;&gt;3.3. 测试代码&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func TestParser(t *testing.T) {
   machineIds := make(chan int)
   snows := CreateSnowFlow(machineIds)
    
   p := Parser{}
   p.AddWorker(100, machineIds, snows)
   p.Run()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">如何 prepend 切片</title><link href="http://localhost:4000/go/2019/02/15/how-to-prepend-a-go-slice.html" rel="alternate" type="text/html" title="如何 prepend 切片" /><published>2019-02-15T22:30:00+08:00</published><updated>2019-02-15T22:30:00+08:00</updated><id>http://localhost:4000/go/2019/02/15/how-to-prepend-a-go-slice</id><content type="html" xml:base="http://localhost:4000/go/2019/02/15/how-to-prepend-a-go-slice.html">&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-示例&quot;&gt;1. 示例&lt;/h2&gt;

&lt;p&gt;直接上码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func Prepend(slice []interface{}, elems ...interface{}) []interface{} {
   if len(elems) &amp;lt;= 0 {
      return slice
   }
    
   ret := slice
   for i := len(elems)-1; i &amp;gt;= 0; i-- {
      ret = append([]interface{}{elems[i]}, ret...)
   }
   return ret
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary></entry></feed>